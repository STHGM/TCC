%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CAPÍTULO 5
\chapter{RESULTADOS E DISCUSSÕES}

Este capítulo apresenta os resultados mais relevantes das comparações. É categorizado por tipo de \emph{collider} e em seguida por tipo de cenário (\emph{Pre-Runtime} e \emph{Runtime}).

A maioria dos resultados com poucos objetos no cenário, ou seja, com um e dez objetos ou objetos gerados por segundo, não apresentaram grandes diferenças entre si em relação a \emph{performance} que pudessem intervir na jogabilidade. Em todas as comparações, os cálculos da física dos objetos foram os que mais consumiram recursos, que foram aumentando conforme o aumento do número de objetos na cena dependendo do tipo de \emph{collider} usado. Mais detalhes podem ser encontrados no apêndice.

A pesquisa de campo foi realizada com vinte e sete pessoas até o dia dezenove de outro de 2019 (19/10/2019), sendo que dezessete delas responderam através do formulário em português e as dez restantes, no formulário em inglês

\section{Pesquisa de Campo}

De acordo com a pesquisa de campo realizada, cerca de 70\% do uso das colisões são de \emph{Box} e \emph{Circle Collider} para suas cenas em 2D como mostra a Figura \ref{resultado_uso_colliders_2d}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Questionario/resultado/04_colliders_2D_mais.png}
	\caption[Frequência de uso de Colliders 2D]{Frequência de uso de \emph{Colliders} 2D.}
	\label{resultado_uso_colliders_2d}
\end{figure}

Em relação as mensagens usadas, há uma distribuição equilibrada quando o uso é de início e final de contato com a colisão ou trigger, como mostra a Figura \ref{resultado_uso_mensagens_2d}. Já enquanto o contato ainda está ocorrendo é pouco utilizado.

O número médio de objetos numa cena podem ser encontrados na Figura \ref{resultado_media_2d}. Nesse resultado apenas dois participantes não responderam à pergunta.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Questionario/resultado/05_mensagens_2D_mais.png}
	\caption[Frequência de uso de mensagens de Colliders 2D]{Frequência de uso de mensagens de \emph{Colliders} 2D.}
	\label{resultado_uso_mensagens_2d}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Questionario/resultado/06_media_2D.png}
	\caption[Média de objetos com Colliders 2D presentes em uma cena]{Média de objetos come \emph{Colliders} 2D presentes em uma cena.}
	\label{resultado_media_2d}
\end{figure}

\section{Resultados com \emph{Box Collider}}

\subsection{\emph{Box Collider - Pre-Runtime}}

Os resultados apresentaram uma progressão linear conforme o número de objetos foi aumentando com pequenas variações. Nos três primeiros testes com um, dez e cinquenta objetos, os resultados se mostram com performance estável, sem queda bruscas de quadros e sem uso intensivo de CPU e de memória RAM.

A partir de cem objetos, apesar de ainda não haver uso intenso de memória e CPU que afetem a jogabilidade, é possível perceber picos de \emph{Garbage Collection}. Esses picos começam a afetar a performance a partir dos quinhentos objetos, fazendo com que o uso total de CPU para calcular os quadros chega a 16 ms como mostrado na Figura \ref{teste_box_10}, onde antes era de 0.25 ms a 1 ms, mostrado na Figura \ref{teste_box_500}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Box/new/0010_Static.png}
	\caption[Resultado 10 Objetos Box Pre-Runtime]{Resultado de performance de dez objetos com \emph{box collider} em \emph{Pre-Runtime}.}
	\label{teste_box_10}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Box/new/0500_Static.png}
	\caption[Resultado 500 Objetos Box Pre-Runtime]{Resultado de performance de quinhentos objetos com \emph{box collider} em \emph{Pre-Runtime}.}
	\label{teste_box_500}
\end{figure}

O resultado com mil objetos foi o mais instável, apresentando um aumento de consumo apenas certo tempo depois do início da execução, chegando a fazer o tempo de consumo total de CPU chegar a 66 ms e 0.65GB de uso total de memória RAM (em comparação com a margem de 200MB de RAM nos resultados anteriores) como mostrado na Figura \ref{teste_box_1000}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Box/new/1000_Static.png}
	\caption[Resultado 1000 Objetos Box Pre-Runtime]{Resultado de performance de mil objetos com \emph{box collider} em \emph{Pre-Runtime}.}
	\label{teste_box_1000}
\end{figure}

\subsection{\emph{Box Collider - Runtime}}

Nos três primeiros testes com um, dez e cinquenta objetos por segundo, os resultados se mostram com performance estável, porém com picos de \emph{Garbage Collection} contantes conforme os objetos eram invocados pelo script de invocação. O consumo total de memória RAM mostra ser menor do que os resultados em \emph{Pre-Runtime}, como mostra a Figura \ref{teste_box_0010_dynamic}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Box/new/0010_Dynamic.png}
	\caption[Resultado 10 Objetos Box Runtime]{Resultado de performance de dez objetos com \emph{box collider} em \emph{Runtime}.}
	\label{teste_box_0010_dynamic}
\end{figure}

A partir de cem objetos por segundo, há uma queda brusca de performance. Foi gerada uma alta quantidade de \emph{Garbage Collection}, taxa de uso de CPU passou o limite de 66 ms e 1.64GB de RAM total, como pode ser mostrado na Figura \ref{teste_box_100_dynamic}, o que afeta bastante a performance, a visualização e estabilidade do jogo. As demais comparações seguintes dessa subseção apresentaram resultados semelhantes, com o aumento de consumo após pouco tempo de execução.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Box/new/0100_Dynamic.png}
	\caption[Resultado 100 Objetos Box Runtime]{Resultado de performance de quinhentos objetos com \emph{box collider} em \emph{Runtime}.}
	\label{teste_box_100_dynamic}
\end{figure}

\section{Resultados com \emph{Circle Collider}}

\subsection{\emph{Circle Collider - Pre-Runtime}}

Assim como nos resultados de \emph{box collider}, as três primeiras comparações se mostraram estáveis nas suas medidas, com tempo de uso de CPU entre 0.25 ms e 1 ms e consumo total de memória RAM em cerca de 250 MB como mostrado na Figura \ref{teste_circle_0050_static}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Circle/new/0050_Static.png}
	\caption[Resultado 0050 Objetos Circle Pre-Runtime]{Resultado de performance de cinquenta objetos com \emph{circle collider} em \emph{Pre-Runtime}.}
	\label{teste_circle_0050_static}
\end{figure}

A partir de 100 objetos em diante, o resultado mostra o início de picos de \emph{Garbage Collection}, que aumentam drasticamente de acordo com o número de objetos na cena. No entanto, com mil objetos, o resultado se mostra estável no início, porém com o aumento de colisões entre os objetos, a quantidade de \emph{Garbage Collection} aumenta, como mostrado na Figura \ref{teste_circle_1000_static}, deixando a performance relativamente baixa. Ela mostra-se melhor do que a mesma situação com \emph{box collider}. Logo em seguida, o \emph{Garbage Collection} diminui, e a performance se estabiliza. O \emph{circle collider} apresentou mais \emph{Garbage Collection} que o \emph{box collider}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Circle/new/1000_Static.png}
	\caption[Resultado 1000 Objetos Circle Pre-Runtime]{Resultado de performance de mil objetos com \emph{circle collider} em \emph{Pre-Runtime}.}
	\label{teste_circle_1000_static}
\end{figure}

\subsection{\emph{Circle Collider - Runtime}}

Segue os mesmos padrões de resultado de \emph{box collider}. porém, os picos de \emph{Garbage Collection} só se tornam mais presentes a partir de 50 objetos por segundo na cena. E até esse ponto, o resultado ainda se mostra estável, com consumo de CPU variando de 1 ms a 5 ms e memória RAM total em cerca de 240 MB, como mostrado na Figura \ref{teste_circle_0050_dynamic}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Circle/new/0050_Dynamic.png}
	\caption[Resultado 50 Objetos Circle Runtime]{Resultado de performance de cinquenta objetos com \emph{circle collider} em \emph{Runtime}.}
	\label{teste_circle_0050_dynamic}
\end{figure}

A partir de cem objetos por segundo, os resultados se assemelham aos cenários com \emph{box collider}, com exceção do consumo total de memória RAM, que teve um aumento significativo de 240 MB com cinquenta objetos, para 1.5 GB, como mostrado na Figura \ref{teste_circle_0100_dynamic}. No entanto, os resultados seguintes mostram consumo de total memória RAM semelhante ao próprio, mesmo com o aumento do número de objetos.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Circle/new/0100_Dynamic.png}
	\caption[Resultado 100 Objetos Circle Runtime]{Resultado de performance de cem objetos com \emph{circle collider} em \emph{Runtime}.}
	\label{teste_circle_0100_dynamic}
\end{figure}

\section{Resultados com \emph{Edge Collider}}
\label{edge-resultados}

\subsection{\emph{Edge Collider - Pre-Runtime}}

Os resultados com esse tipo de \emph{collider} mostraram-se estáveis em todos os cenários, tendo baixo consumo de processamento, que com mil objetos chegou a 1 ms, e uso total de memória RAM com pouca variação em comparação com os outros \emph{colliders}, variando entre 250 MB e 350 MB para até 500 objetos, e cerca de 450 MB para mil objetos como demonstrado pela Figura \ref{teste_edge_1000_static}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Circle/new/1000_Static.png}
	\caption[Resultado 1000 Objetos Edge Pre-Runtime]{Resultado de performance de mil objetos com \emph{edge collider} em \emph{Pre-Runtime}.}
	\label{teste_edge_1000_static}
\end{figure}

No entanto foi o que demonstrou a menor precisão em como as colisões ocorrem. Os objetos, mesmo com \emph{rigid body}, se sobrepunham uns entre os outros. Além disso, como esse tipo de \emph{collider} consiste de uma linha contínua, não é apropriado para o uso de personagens ou objetos que requerem uma interação mais dinâmica. Esse tipo de \emph{collider} é mais apropriado para terrenos e plataformas que não requerem uma interação além de uma parte da superfície. Outro problema observado pelo uso de muitos objetos com \emph{edge collider} na mesma cena é que alguns deles podem atravessar outros objetos, mesmo estando com \emph{rigidbody}. Esses problemas podem ser vistos por meio da Figura \ref{teste_edge_1000_static_artifact}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Edge/new/1000_Static_Artifact.png}
	\caption[Problemas 1000 Objetos Edge Pre-Runtime]{Problemas de colisão causados pelo uso do tipo \emph{edge collider} em \emph{Pre-Runtime}.}
	\label{teste_edge_1000_static_artifact}
\end{figure}

\subsection{\emph{Edge Collider - Runtime}}

Os resultados nessa categoria mostraram-se estáveis em seu percurso, tendo mais performance do que os resultados em \emph{Pre-Runtime}. Com mil objetos por segundo, o tempo de uso de CPU ficou entre 5 ms e 10 ms, e consumo total de memória RAM em cerca de 320 MB, como mostra a Figura \ref{teste_edge_1000_dynamic}. Picos de \emph{Garbage Collection} começam a ser mais frequentes a partir de cem objetos por segundo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Edge/new/1000_Dynamic.png}
	\caption[Resultado 1000 Objetos Edge Runtime]{Resultado de performance de mil objetos por segundo com \emph{edge collider} em \emph{Runtime}.}
	\label{teste_edge_1000_dynamic}
\end{figure}

\section{Resultado com \emph{Polygon Collider}}

O \emph{Polygon Collider} é o tipo de \emph{collider} que oferece a melhor precisão de colisão em comparação aos outros. No entanto, é o que requer mais uso de recursos, o que resulta em uma performance baixa se usado com muita frequência.

Devido a isso, os resultados em Runtime a partir de 50 objetos já demonstraram uma queda brusca na performance. Com 100 objetos ou mais não foi possível realizar as medições, pois o programa não respondeu mais ao iniciar a execução.

\subsection{\emph{Polygon Collider - Pre-Runtime}}

Os resultados com um e cem objetos, demonstram boa estabilidade  de consumo de recursos, mantendo o tempo de consumo total da CPU entre 0.1 ms e 1 ms, como mostra a Figura \ref{teste_polygon_0010_static}. O consumo total de memória RAM variou entre 270 MB e 180 MB.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Polygon/new/0010_Static.png}
	\caption[Resultado 10 Objetos Polygon Pre-Runtime]{Resultado de performance de dez objetos com \emph{polygon collider} em \emph{Pre-Runtime}.}
	\label{teste_polygon_0010_static}
\end{figure}

A partir de 50 objetos, houve um consumo maior de CPU, fazendo o tempo total de uso da mesma ser entre 5 ms a 16 ms. No entanto, apesar do consumo total de memória RAM se manteve estável como mostra a Figura \ref{teste_polygon_0050_static}, a performance começa a cair gradativamente.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Polygon/new/0050_Static.png}
	\caption[Resultado 50 Objetos Polygon Pre-Runtime]{Resultado de performance de cinquenta objetos com \emph{polygon collider} em \emph{Pre-Runtime}.}
	\label{teste_polygon_0050_static}
\end{figure}

Com cem objetos a performance diminui pouco, relativamente ao resultado anterior. O consumo total de memória RAM se mantém, e o tempo de consumo da CPU teve um pico de 66 ms, porém, em sua maioria, manteve estável entre 33 ms e 16 ms como mostra a Figura \ref{teste_polygon_0100_static}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Polygon/new/0100_Static.png}
	\caption[Resultado 100 Objetos Polygon Pre-Runtime]{Resultado de performance de cem objetos com \emph{polygon collider} em \emph{Pre-Runtime}.}
	\label{teste_polygon_0100_static}
\end{figure}

Os resultados com quinhentos e mil objetos demonstraram uma queda drástica na performance, além de uso elevado dos recursos, com consumo total de memória RAM sendo de 0.99 GB e 1.88 GB respectivamente, e em ambos o tempo de consumo de CPU passou de 66 ms, como mostra a Figura \ref{teste_polygon_0500_static}. Com mil objetos, a taxa de quadros por segundo se manteve em 0.6 (1638 ms), como mostra a Figura .

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Polygon/new/0500_Static.png}
	\caption[Resultado 500 Objetos Polygon Pre-Runtime]{Resultado de performance de quinhentos objetos com \emph{polygon collider} em \emph{Pre-Runtime}.}
	\label{teste_polygon_0500_static}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/1000_Static_FPS.png}
	\caption[Quadros por segundo 1000 Objetos Polygon Pre-Runtime]{Captura de quadros por segundo média aproximada com \emph{polygon collider} em \emph{Pre-Runtime} e mil objetos.}
	\label{teste_polygon_1000_static_fps}
\end{figure}

\subsection{\emph{Polygon Collider - Runtime}}

O resultado com um objeto por segundo foi relativamente estável, apresentando tempo de consumo de CPU com média de 1 ms e consumo total de memória RAM com 230 MB, como mostra a Figura \ref{teste_polygon_0001_dynamic}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Polygon/new/0001_Dynamic.png}
	\caption[Resultado 1 Objeto Polygon Runtime]{Resultado de performance de um objeto com \emph{polygon collider} em \emph{Runtime}.}
	\label{teste_polygon_0001_dynamic}
\end{figure}

A partir de 10 objetos por segundo a performance começa a cair conforme o tempo de execução passa e os objetos são inseridos. Inicialmente o tempo de consumo de CPU era de cerca de 16 ms, porém rapidamente passou de 66 ms como mostra a Figura \ref{teste_polygon_0010_dynamic}. O consumo de memória RAM total foi de cerca de 500 MB.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Polygon/new/0010_Dynamic.png}
	\caption[Resultado 10 Objetos Polygon Runtime]{Resultado de performance de dez objetos com \emph{polygon collider} em \emph{Runtime}.}
	\label{teste_polygon_0010_dynamic}
\end{figure}

Com 50 Objetos, a performance é comprometida desde o início da execução, fazendo com que o programa travasse com frequência. O tempo de consumo de CPU que foi possível medir passou de 66 ms e consumo total de memória RAM de 335 MB como mostra a Figura \ref{teste_polygon_0050_dynamic} até ser encerrada a execução pelo programa por travar frequentemente. O programa indicou 0.8 quadros por segundo (1209 ms) como mostra a Figura  e se manteve assim durante o resto da execução

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Polygon/new/0050_Dynamic_Stats.png}
	\caption[Resultado 50 Objetos Polygon Runtime]{Resultado de performance de cinquenta objetos com \emph{polygon collider} em \emph{Runtime}.}
	\label{teste_polygon_0050_dynamic}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/0050_Dynamic_FPS.png}
	\caption[Quadros por segundo 50 Objetos Polygon Runtime]{Captura de quadros por segundo média aproximada com \emph{polygon collider} em \emph{Runtime} e cinquenta objetos.}
	\label{teste_polygon_0050_dynamic_fps}
\end{figure}

Com cem objetos por segundo, o programa inicia, porém não prossegue com a execução. Por manter-se parado dessa forma por um longo período de tempo, essa comparação foi cancelada e não foi possível obter resultados.

As comparações com quinhentos e mil objetos por segundo apresentaram o mesmo efeito e também foram cancelados.

\section{Visão Geral dos resultados}

Como foi possível observar pela análise dos resultados, a maioria das comparações com um alto número de objetos já inseridos na cena ou objetos gerados por segundo, exigiram mais dos recursos da máquina, causando degradação da performance durante a execução. E nos casos do \emph{Polygon collider} com cem objetos por segundo em diante o programa travou e não foi possível obter resultados.

As comparações com poucos objetos não demonstraram grandes diferenças entre si.

O tipo de \emph{collider} que requisitou maior quantidade de recursos na maioria de suas comparações certamente foi o \emph{Polygon Collider}, pelo fato de ser um tipo de colisão que tenta se encaixar melhor com o formato do objeto original. Isso gera uma precisão melhor na colisão, porém em excesso, causa degradação da performance. No entanto, se o não usado com muita frequência e o escopo exigir precisão, é possível usá-lo sem perder muita performance.

Em comparação com os \emph{colliders} mais utilizados (\emph{Box collider 2D} e \emph{Circle Collider 2D}), de acordo com a pesquisa de campo na Figura \ref{resultado_uso_colliders_2d}, eles mostram resultados de performance melhores e, muitas vezes, se encaixam no escopo do que é necessário para ser realizado nas colisões de um devido jogo. Se o jogo ou alguns objetos da cena não necessitarem muita precisão da colisão, as formas básicas podem ser o suficiente para o funcionamento e escopo do jogo.

A seguir são mostrados os principais gráficos dos resultados com cinquenta objetos inseridos antes de executar o programa e cinquenta objetos por segundo durante a execução. Cinquenta objetos por ser um número médio mais próximo da quantidade de objetos usados por cena de acordo com a pesquisa de campo na Figura \ref{resultado_media_2d}.

O atributo física foi removido da maioria dos gráficos por obstruir a visualização dos outros atributos que, na maioria dos casos apresentam valores muito menores que os da física, mais informações dos dados brutos podem ser encontradas no apêndice \ref{chap:apendiceC}. E todos os métodos apresentados nos gráficos são referentes aos métodos da interface 2D da \emph{Unity}, por exemplo: \emph{TriggerStay = TriggerStay2D}. Métodos \emph{Collision} foram abreviados, por exemplo: \emph{ColEnter = CollisionEnter2D}.

Os resultados com \emph{Edge Collider} não foram incluídos por serem os mais estáveis, como mencionado na seção \ref{edge-resultados}.

\subsection{Comparações em Pre-Runtime}

É possível observar nos gráficos de porcentagem de uso total da CPU das Figuras \ref{grafico_box_static_percent}, \ref{grafico_circle_static_percent} e \ref{grafico_polygon_static_percent} que os \emph{colliders Box} e \emph{Circle} apresentaram resultados bem semelhantes, com picos chegando a 1.4\% do uso total da CPU, e média variando entre 0.02\% e 0.05\%. O \emph{Polygon collider} apresentou resultados semelhantes também, porém com a diferença nos picos, chegando a 2.5\% de uso total da CPU.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Box/Pre-Runtime/50_Percent_NP.png}
	\caption[Gráfico de porcentagem de uso da CPU com 50 objetos Box Collider em Pre-Runtime]{Gráfico de porcentagem de uso da CPU com 50 objetos \emph{Box Collider} em \emph{Pre-Runtime}.}
	\label{grafico_box_static_percent}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Circle/Pre-Runtime/50_Percent_NP.png}
	\caption[Gráfico de porcentagem de uso da CPU com 50 objetos Circle Collider em Pre-Runtime]{Gráfico de porcentagem de uso da CPU com 50 objetos \emph{Circle Collider} em \emph{Pre-Runtime}.}
	\label{grafico_circle_static_percent}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Pre-Runtime/50_Percent_NP.png}
	\caption[Gráfico de porcentagem de uso da CPU com 50 objetos Polygon Collider em Pre-Runtime]{Gráfico de porcentagem de uso da CPU com 50 objetos \emph{Polygon Collider} em \emph{Pre-Runtime}.}
	\label{grafico_polygon_static_percent}
\end{figure}


Em relação ao número de vezes que os métodos que foram chamados durante a execução, são mostrados nos gráficos das Figuras \ref{grafico_box_static_calls}, \ref{grafico_circle_static_calls} e \ref{grafico_polygon_static_calls}. É possível observar que o método \emph{CollisionStay2D} foi o que mais requisitou chamadas, e o segundo que mais requisitou foi o \emph{TriggerStay2D}. Também é possível notar que com o \emph{collider Polygon} houve maior número de chamadas durante a execução, que se mantiveram estáveis com o decorrer do tempo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Box/Pre-Runtime/50_Calls_NP.png}
	\caption[Gráfico de número de vezes que o método foi chamado com 50 objetos Box Collider em Pre-Runtime]{Gráfico de número de vezes que o método foi chamado com 50 objetos \emph{Box Collider} em \emph{Pre-Runtime}.}
	\label{grafico_box_static_calls}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Circle/Pre-Runtime/50_Calls_NP.png}
	\caption[Gráfico de número de vezes que o método foi chamado com 50 objetos Circle Collider em Pre-Runtime]{Gráfico de número de vezes que o método foi chamado com 50 objetos \emph{Circle Collider} em \emph{Pre-Runtime}.}
	\label{grafico_circle_static_calls}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Pre-Runtime/50_Calls_NP.png}
	\caption[Gráfico de número de vezes que o método foi chamado com 50 objetos Polygon Collider em Pre-Runtime]{Gráfico de número de vezes que o método foi chamado com 50 objetos \emph{Polygon Collider} em \emph{Pre-Runtime}.}
	\label{grafico_polygon_static_calls}
\end{figure}


O tempo em milissegundos exigido para a execução de cada método é exibido nos gráficos das Figuras \ref{grafico_box_static_time}, \ref{grafico_circle_static_time} e \ref{grafico_polygon_static_time}. E a partir deles é possível observar que novamente os métodos \emph{CollisionStay2D} e \emph{TriggerStay2D} foram os que mais exigiram do recurso. É possível também notar que o \emph{Circle collider} apresentou melhor performance em relação ao \emph{Box collider}. O \emph{Polygon collider} continua sendo o menos performático.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Box/Pre-Runtime/50_Time_NP.png}
	\caption[Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos Box Collider em Pre-Runtime]{Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos \emph{Box Collider} em \emph{Pre-Runtime}.}
	\label{grafico_box_static_time}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Circle/Pre-Runtime/50_Time_NP.png}
	\caption[Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos Circle Collider em Pre-Runtime]{Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos \emph{Circle Collider} em \emph{Pre-Runtime}.}
	\label{grafico_circle_static_time}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Pre-Runtime/50_Time_NP.png}
	\caption[Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos Polygon Collider em Pre-Runtime]{Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos \emph{Polygon Collider} em \emph{Pre-Runtime}.}
	\label{grafico_polygon_static_time}
\end{figure}


A coleta de lixo (\emph{Garbage Collection}) desses métodos com os \emph{colliders} mencionados só mostrou variâncias quando o atributo física está presente. Sem ele, os métodos não mostraram alteração de quantidade de coleta de lixo, com exceção do \emph{Polygon collider} que apresentou apenas 32 bytes no quadro 41 com o \emph{TriggerEnter2D} e depois para zero, como mostra o gráfico na Figura \ref{grafico_polygon_static_gc}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Pre-Runtime/50_GCMemory_NP.png}
	\caption[Gráfico de quantidade de Garbage Collection em bytes com 50 objetos Polygon Collider em Pre-Runtime]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos \emph{Polygon Collider} em \emph{Pre-Runtime}.}
	\label{grafico_polygon_static_gc}
\end{figure}

A seguir é exibido nos gráficos das Figuras \ref{grafico_box_static_gc}, \ref{grafico_circle_static_gc} e \ref{grafico_polygon_static_gc_p}, o \emph{Garbage Collection} com física. Com isso é possível observar que o \emph{Circle collider} apresentou total estabilidade de 30000 \emph{bytes}, com alguns picos de quase 60000 \emph{bytes}, porém foi o único que já iniciou com \emph{Garbage Collection}. Os \emph{colliders Box} e \emph{Polygon} foram aumentando com o passar do tempo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Box/Pre-Runtime/50_GCMemory_P.png}
	\caption[Gráfico de quantidade de Garbage Collection em bytes com 50 objetos Box Collider em Pre-Runtime com física]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos \emph{Box Collider} em \emph{Pre-Runtime} com física.}
	\label{grafico_box_static_gc}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Circle/Pre-Runtime/50_GCMemory_P.png}
	\caption[Gráfico de quantidade de Garbage Collection em bytes com 50 objetos Circle Collider em Pre-Runtime com física]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos \emph{Circle Collider} em \emph{Pre-Runtime} com física.}
	\label{grafico_circle_static_gc}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Pre-Runtime/50_GCMemory_P.png}
	\caption[Gráfico de quantidade de Garbage Collection em bytes com 50 objetos Polygon Collider em Pre-Runtime com física]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos \emph{Polygon Collider} em \emph{Pre-Runtime} com física.}
	\label{grafico_polygon_static_gc_p}
\end{figure}

As Figuras \ref{grafico_box_static}, \ref{grafico_circle_static} e \ref{grafico_polygon_static} apresentam o gráfico geral de resultados dos \emph{colliders Box, Circle} e \emph{Polygon} no cenário \emph{Pre-Runtime}. Neles é possível observar o consumo total de memória RAM, bem como a progressão de milissegundos necessários para renderizar os quadros. A tabela \ref{tabela_ms_to_fps} a seguir mostra a conversão de alguns valores em milissegundos para FPS (Quadros por segundo) para melhor entendimento dos gráficos.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[]
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|l|l|}
			\hline
			\multicolumn{2}{|l|}{Conversão milissegundos para FPS} \\ \hline
			1 ms & 1000 FPS \\ \hline
			2 ms & 500 FPS \\ \hline
			4.17 ms & 240 FPS \\ \hline
			8.34 ms & 120 FPS \\ \hline
			10 ms & 100 FPS \\ \hline
			16.67 ms & 60 FPS \\ \hline
			33.34 ms & 30 FPS \\ \hline
			66.67 ms & 15 FPS \\ \hline
			100 ms & 10 FPS \\ \hline
			200 ms & 5 FPS \\ \hline
			1000 ms & 1 FPS \\ \hline
			1250 ms & 0.8 FPS \\ \hline
			2000 ms & 0.5 FPS \\ \hline
			5000 ms & 0.2 FPS \\ \hline
			10000 ms & 0.1 FPS \\ \hline
		\end{tabular}%
	}
	\caption{Tabela de conversão de milissegundos para FPS (quadros por segundo).}
	\label{tabela_ms_to_fps}
\end{table}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Box/new/0050_Static.png}
	\caption[Gráfico do resultado de Box Collider com 50 objetos em Pre-Runtime]{Gráfico do resultado de \emph{Box Collider} com 50 objetos em \emph{Pre-Runtime}.}
	\label{grafico_box_static}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Circle/new/0050_Static.png}
	\caption[Gráfico do resultado de Circle Collider com 50 objetos em Pre-Runtime]{Gráfico do resultado de \emph{Circle Collider} com 50 objetos em \emph{Pre-Runtime}.}
	\label{grafico_circle_static}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Polygon/new/0050_Static.png}
	\caption[Gráfico do resultado de Polygon Collider com 50 objetos em Pre-Runtime]{Gráfico do resultado de Polygon Collider com 50 objetos em \emph{Pre-Runtime}.}
	\label{grafico_polygon_static}
\end{figure}


\subsection{Comparações em \emph{Runtime}}

Nas comparações a seguir foi adicionado o atributo \emph{Spawn}, referente ao método que invoca os objetos em tempo de execução, para ser medido.

Com os gráficos de porcentagem de uso total da CPU mostrados nas Figuras \ref{grafico_box_dynamic_percent}, \ref{grafico_circle_dynamic_percent} e \ref{grafico_polygon_dynamic_percent}, é possível notar que o \emph{Circle collider} se mostrou mais estável e mais performático que o \emph{Box collider}. O \emph{Polygon collider} apresenta pouca amostra de dados por ser o resultado que começou a apresentar travamentos no programa, o que justifica o limite baixo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Box/Runtime/50_Percent_NP.png}
	\caption[Gráfico de porcentagem de uso da CPU com 50 objetos por segundo Box Collider em Runtime]{Gráfico de porcentagem de uso da CPU com 50 objetos por segundo \emph{Box Collider} em \emph{Runtime}.}
	\label{grafico_box_dynamic_percent}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Circle/Runtime/50_Percent_NP.png}
	\caption[Gráfico de porcentagem de uso da CPU com 50 objetos Circle Collider em Runtime]{Gráfico de porcentagem de uso da CPU com 50 objetos \emph{Circle Collider} em \emph{Runtime}.}
	\label{grafico_circle_dynamic_percent}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Runtime/50_Percent_NP.png}
	\caption[Gráfico de porcentagem de uso da CPU com 50 objetos po segundo Polygon Collider em Runtime]{Gráfico de porcentagem de uso da CPU com 50 objetos por segundo \emph{Polygon Collider} em \emph{Runtime}.}
	\label{grafico_polygon_dynamic_percent}
\end{figure}


Em relação ao número de vezes que os métodos que foram chamados durante a execução, são mostrados nos gráficos das Figuras \ref{grafico_box_dynamic_calls}, \ref{grafico_circle_dynamic_calls} e \ref{grafico_polygon_dynamic_calls}. É possível notar que o \emph{Circle collider} demonstrou ser bem mais performático e estável nesse quesito em relação ao \emph{Box collider}. O \emph{Polygon collider} mostrou um aumento conforme o passar do tempo, ultrapassando o total do \emph{Circle} e \emph{Box collider} em menos tempo que os mesmos.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Box/Runtime/50_Calls_NP.png}
	\caption[Gráfico de número de vezes que o método foi chamado com 50 objetos Box Collider em Runtime]{Gráfico de número de vezes que o método foi chamado com 50 objetos por segundo \emph{Box Collider} em \emph{Runtime}.}
	\label{grafico_box_dynamic_calls}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Circle/Runtime/50_Calls_NP.png}
	\caption[Gráfico de número de vezes que o método foi chamado com 50 objetos por segundo Circle Collider em Runtime]{Gráfico de número de vezes que o método foi chamado com 50 objetos \emph{Circle Collider} em \emph{Runtime}.}
	\label{grafico_circle_dynamic_calls}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Runtime/50_Calls_NP.png}
	\caption[Gráfico de número de vezes que o método foi chamado com 50 objetos por segundo Polygon Collider em Runtime]{Gráfico de número de vezes que o método foi chamado com 50 objetos \emph{Polygon Collider} em \emph{Runtime}.}
	\label{grafico_polygon_dynamic_calls}
\end{figure}


O tempo em milissegundos exigido para a execução de cada método é exibido nos gráficos das Figuras \ref{grafico_box_dynamic_time}, \ref{grafico_circle_dynamic_time} e \ref{grafico_polygon_dynamic_time}. E a partir deles é possível observar que o \emph{Circle} e \emph{Box collider} mostraram-se estáveis, com o método \emph{Spawn} exigindo mais tempo em ambos, e o \emph{CollisionStay2D} para o \emph{Box collider}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Box/Runtime/50_Time_NP.png}
	\caption[Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos por segundo Box Collider em Runtime]{Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos por segundo \emph{Box Collider} em \emph{Runtime}.}
	\label{grafico_box_dynamic_time}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Circle/Runtime/50_Time_NP.png}
	\caption[Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos por segundo Circle Collider em Pre-Runtime]{Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos por segundo \emph{Circle Collider} em \emph{Runtime}.}
	\label{grafico_circle_dynamic_time}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Runtime/50_Time_NP.png}
	\caption[Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos por segundo Polygon Collider em Runtime]{Gráfico de tempo em milissegundos exigido pelo processador para executar o método com 50 objetos por segundo \emph{Polygon Collider} em \emph{Runtime}.}
	\label{grafico_polygon_dynamic_time}
\end{figure}


A seguir é exibido nos gráficos das Figuras \ref{grafico_box_dynamic_gc}, \ref{grafico_circle_dynamic_gc} e \ref{grafico_polygon_dynamic_gc}, o \emph{Garbage Collection} dos métodos. Em todos os gráficos é possível notar que o método spawn foi o mais usado no \emph{Garbage Collection}, sendo o \emph{Circle collider} o mais estável deles.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Box/Runtime/50_GCMemory_NP.png}
	\caption[Gráfico de quantidade de Garbage Collection em bytes com 50 objetos por segundo Box Collider em Runtime]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos por segundo \emph{Box Collider} em \emph{Runtime}.}
	\label{grafico_box_dynamic_gc}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Circle/Runtime/50_GCMemory_NP.png}
	\caption[Gráfico dequantidade de Garbage Collection em bytes com 50 objetos por segundo Circle Collider em Runtime]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos por segundo \emph{Circle Collider} em \emph{Runtime}.}
	\label{grafico_circle_dynamic_gc}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Runtime/50_GCMemory_NP.png}
	\caption[Gráfico de quantidade de Garbage Collection em bytes com 50 objetos por segundo Polygon Collider em Runtime]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos por segundo \emph{Polygon Collider} em \emph{Runtime}.}
	\label{grafico_polygon_dynamic_gc}
\end{figure}

Os gráficos a seguir apresentados pelas Figuras \ref{grafico_box_dynamic_gc_p}, \ref{grafico_circle_dynamic_gc_p} e \ref{grafico_polygon_dynamic_gc_p}, o \emph{Garbage Collection} dos métodos, porém com o atributo física sendo visualizado. Neles é possível observar que o \emph{Box collider} apresenta aumento de coleta de lixo conforme os quadros são renderizados e o \emph{Circle collider} apresenta pouca estabilidade, porém tem menos coleta de lixo. Já o \emph{Polygon collider} é o mais instável, chegando ao dobro da coleta de lixo em comparação aos outros, mesmo com uma quantidade menor de quadros.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Box/Runtime/50_GCMemory_P.png}
	\caption[Gráfico de quantidade de Garbage Collection em bytes com 50 objetos por segundo Box Collider em Runtime com física]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos por segundo \emph{Box Collider} em \emph{Runtime} com física.}
	\label{grafico_box_dynamic_gc_p}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Circle/Runtime/50_GCMemory_P.png}
	\caption[Gráfico dequantidade de Garbage Collection em bytes com 50 objetos por segundo Circle Collider em Runtime com física]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos por segundo \emph{Circle Collider} em \emph{Runtime} com física.}
	\label{grafico_circle_dynamic_gc_p}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Graficos/Polygon/Runtime/50_GCMemory_P.png}
	\caption[Gráfico de quantidade de Garbage Collection em bytes com 50 objetos por segundo Polygon Collider em Runtime com física]{Gráfico de quantidade de \emph{Garbage Collection} em \emph{bytes} com 50 objetos por segundo \emph{Polygon Collider} em \emph{Runtime} com física.}
	\label{grafico_polygon_dynamic_gc_p}
\end{figure}

As Figuras \ref{grafico_box_dynamic}, \ref{grafico_circle_dynamic} e \ref{grafico_polygon_dynamic} apresentam o gráfico geral de resultados dos \emph{colliders Box, Circle} e \emph{Polygon} no cenário \emph{Runtime}. Neles é possível observar o consumo total de memória RAM, bem como a progressão de milissegundos necessários para renderizar os quadros. Novamente, a tabela \ref{tabela_ms_to_fps} pode ser usada como referência para as conversões.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Box/new/0050_Dynamic.png}
	\caption[Gráfico do resultado de Box Collider com 50 objetos em Runtime]{Gráfico do resultado de \emph{Box Collider} com 50 objetos em \emph{Runtime}.}
	\label{grafico_box_dynamic}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Circle/new/0050_Dynamic.png}
	\caption[Gráfico do resultado de Circle Collider com 50 objetos em Runtime]{Gráfico do resultado de \emph{Circle Collider} com 50 objetos em \emph{Runtime}.}
	\label{grafico_circle_dynamic}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\textwidth]{./Figuras/Testes/Polygon/new/0050_Dynamic_Stats.png}
	\caption[Gráfico do resultado de Polygon Collider com 50 objetos em Runtime]{Gráfico do resultado de Polygon Collider com 50 objetos em \emph{Runtime}.}
	\label{grafico_polygon_dynamic}
\end{figure}
