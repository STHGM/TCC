%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CAPÍTULO 5
\chapter{RESULTADOS E DISCUSSÕES} 

Este capítulo apresentará os resultados mais relevantes das comparações. É categorizado por tipo de \emph{collider}e depois por tipo de cenário (\emph{Pre-Runtime} e \emph{Runtime}).

A maioria dos resultados com poucos objetos no cenário, ou seja, com um e dez objetos, não apresentaram grandes diferenças entre si em questão de performance que pudessem intervir na jogabilidade. Em todas as comparações, os cálculos da física dos objetos foram os que mais consumiram recursos, que foram aumentando conforme o aumento do número de objetos na cena dependendo do tipo de \emph{collider} usado, como pode ser encontrado nos Anexos.

\section{Resultados com \emph{Box Collider}}

\subsection{\emph{Box Collider - Pre-Runtime}}

Os resultados apresentaram uma progressão linear conforme o número de objetos foi aumentando com pequenas variações. Nos três primeiros testes com um, dez e cinquenta objetos, os resultados se mostram com performance estável, sem queda bruscas de quadros e sem uso intensivo de CPU e de memória RAM.

A partir de cem objetos, apesar de ainda não haver uso intenso de memória e CPU que afetem a jogabilidade, é possível perceber picos de \emph{Garbage Collection}. Esses picos começam a afetar a performance a partir dos quinhentos objetos, fazendo com que o uso total de CPU para calcular os quadros chega a 16 ms como mostrado na Figura \ref{teste_box_10}, onde antes era de 0.25 ms a 1 ms, mostrado na Figura \ref{teste_box_500}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Box/new/0010_Static.png}
	\caption[Resultado 10 Objetos Box Static]{Resultado de performance de dez objetos com \emph{box collider} em \emph{Pre-Runtime}.}
	\label{teste_box_10}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Box/new/0500_Static.png}
	\caption[Resultado 500 Objetos Box Static]{Resultado de performance de quinhentos objetos com \emph{box collider} em \emph{Pre-Runtime}.}
	\label{teste_box_500}
\end{figure}

O resultado com mil objetos foi o mais instável, apresentando um aumento de consumo apenas certo tempo depois do início da execução, chegando a fazer o tempo de consumo total de CPU chegar a 66 ms e 0.65GB de uso total de memória RAM (em comparação com a margem de 200MB de RAM nos resultados anteriores) como mostrado na Figura \ref{teste_box_1000}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Box/new/1000_Static.png}
	\caption[Resultado 1000 Objetos Box Static]{Resultado de performance de mil objetos com \emph{box collider} em \emph{Pre-Runtime}.}
	\label{teste_box_1000}
\end{figure}

\subsection{\emph{Box Collider - Runtime}}

Nos três primeiros testes com um, dez e cinquenta objetos por segundo, os resultados se mostram com performance estável, porém com picos de \emph{Garbage Collection} contantes conforme os objetos eram invocados pelo script de invocação. O consumo total de memória RAM mostra ser menor do que os resultados em \emph{Pre-Runtime}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Box/new/0010_Dynamic.png}
	\caption[Resultado 10 Objetos Box Dynamic]{Resultado de performance de dez objetos com \emph{box collider} em \emph{Runtime}.}
	\label{teste_box_0010_dynamic}
\end{figure}

A partir de cem objetos por segundo, há uma queda brusca de performance. Foi gerada uma alta quantidade de \emph{Garbage Collection}, taxa de uso de CPU passou o limite de 66 ms e 1.64GB de RAM total, como pode ser mostrado na Figura \ref{teste_box_100_dynamic}, o que afeta bastante a performance, a visualização e estabilidade do jogo. As demais comparações seguintes dessa subseção apresentaram resultados semelhantes, com o aumento de consumo após pouco tempo de execução.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Box/new/0100_Dynamic.png}
	\caption[Resultado 100 Objetos Box Dynamic]{Resultado de performance de quinhentos objetos com \emph{box collider} em \emph{Runtime}.}
	\label{teste_box_100_dynamic}
\end{figure}

\section{Resultados com \emph{Circle Collider}}

\subsection{\emph{Circle Collider - Pre-Runtime}}

Assim como nos resultados de \emph{box collider}, as três primeiras comparações se mostraram estáveis nas suas medidas, com tempo de uso de CPU entre 0.25 ms e 1 ms e consumo total de memória RAM em cerca de 250 MB como mostrado na Figura \ref{teste_circle_0050_static}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Circle/new/0050_Static.png}
	\caption[Resultado 0050 Objetos Circle Static]{Resultado de performance de cinquenta objetos com \emph{circle collider} em \emph{Pre-Runtime}.}
	\label{teste_circle_0050_static}
\end{figure}

A partir de 100 objetos em diante, o resultado mostra o início de picos de \emph{Garbage Collection}, que aumentam drasticamente de acordo com o número de objetos na cena. No entanto, com mil objetos, o resultado se mostra estável no início, porém com o aumento de colisões entre os objetos, a quantidade de \emph{Garbage Collection} aumenta, como mostrado na Figura \ref{teste_circle_1000_static}, deixando a performance relativamente baixa. Ela mostra-se melhor do que a mesma situação com \emph{box collider}. Logo em seguida, o \emph{Garbage Collection} diminui, e a performance se estabiliza. O \emph{circle collider} apresentou mais \emph{Garbage Collection} que o \emph{box collider}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Circle/new/1000_Static.png}
	\caption[Resultado 1000 Objetos Circle Static]{Resultado de performance de mil objetos com \emph{circle collider} em \emph{Pre-Runtime}.}
	\label{teste_circle_1000_static}
\end{figure}

\subsection{\emph{Circle Collider - Runtime}}

Segue os mesmos padrões de resultado de \emph{box collider}. porém, os picos de \emph{Garbage Collection} só se tornam mais presentes a partir de 50 objetos por segundo na cena. E até esse ponto, o resultado ainda se mostra estável, com consumo de CPU variando de 1 ms a 5 ms e memória RAM total em cerca de 240 MB, como mostrado na Figura \ref{teste_circle_0050_dynamic}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Circle/new/0050_Dynamic.png}
	\caption[Resultado 0050 Objetos Circle Dynamic]{Resultado de performance de cinquenta objetos com \emph{circle collider} em \emph{Runtime}.}
	\label{teste_circle_0050_dynamic}
\end{figure}

A partir de cem objetos por segundo, os resultados se assemelham aos cenários com \emph{box collider}, com exceção do consumo total de memória RAM, que teve um aumento significativo de 240 MB com cinquenta objetos, para 1.5 GB, como mostrado na Figura \ref{teste_circle_0100_dynamic}. No entanto, os resultados seguintes mostram consumo de total memória RAM semelhante ao próprio, mesmo com o aumento do número de objetos.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Circle/new/0100_Dynamic.png}
	\caption[Resultado 0100 Objetos Circle Dynamic]{Resultado de performance de cem objetos com \emph{circle collider} em \emph{Runtime}.}
	\label{teste_circle_0100_dynamic}
\end{figure}

\section{Resultados com \emph{Edge Collider}}

\subsection{\emph{Edge Collider - Pre-Runtime}}

Os resultados com esse tipo de \emph{collider} mostraram-se estáveis em todos os cenários, tendo baixo consumo de processamento, que com mil objetos chegou a 1 ms, e uso total de memória RAM com pouca variação em comparação com os outros \emph{colliders}, variando entre 250 MB e 350 MB para até 500 objetos, e cerca de 450 MB para mil objetos como demonstrado pela Figura \ref{teste_edge_1000_static}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Circle/new/1000_Static.png}
	\caption[Resultado 1000 Objetos Edge Static]{Resultado de performance de mil objetos com \emph{edge collider} em \emph{Pre-Runtime}.}
	\label{teste_edge_1000_static}
\end{figure}

No entanto foi o que demonstrou a menor precisão em como as colisões ocorrem. Os objetos, mesmo com \emph{rigid body}, se sobrepunham uns entre os outros. Além disso, como esse tipo de \emph{collider} consiste de uma linha contínua, não é apropriado para o uso de personagens ou objetos que requerem uma interação mais dinâmica. Esse tipo de \emph{collider} é mais apropriado para terrenos e plataformas que não requerem uma interação além de uma parte da superfície. Outro problema observado pelo uso de muitos objetos com \emph{edge collider} na mesma cena é que alguns deles podem atravessar outros objetos, mesmo estando com \emph{rigidbody}. Esses problemas podem ser vistos por meio da Figura \ref{teste_edge_1000_static_artifact}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Edge/new/1000_Static_Artifact.png}
	\caption[Problemas 1000 Objetos Edge Static Artifact]{Problemas de colisão causados pelo uso do tipo \emph{edge collider} em \emph{Pre-Runtime}.}
	\label{teste_edge_1000_static_artifact}
\end{figure}

\subsection{\emph{Edge Collider - Runtime}}

Os resultados nessa categoria mostraram-se estáveis em seu percurso, tendo mais performance do que os resultados em \emph{Pre-Runtime}. Com mil objetos por segundo, o tempo de uso de CPU ficou entre 5 ms e 10 ms, e consumo total de memória RAM em cerca de 320 MB, como mostra a Figura . Picos de \emph{Garbage Collection} começam a ser mais frequentes a partir de cem objetos por segundo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Edge/new/1000_Dynamic.png}
	\caption[Resultado 1000 Objetos Edge Dynamic]{Resultado de performance de mil objetos por segundo com \emph{edge collider} em \emph{Runtime}.}
	\label{teste_edge_1000_dynamic}
\end{figure}

\section{Resultado com \emph{Polygon Collider}}

O \emph{Polygon Collider} é o tipo de \emph{collider} que oferece a melhor precisão de colisão em comparação aos outros. No entanto, é o que requer mais uso de recursos, o que resulta em uma performance baixa se usado com muita frequência.

Devido a isso, os resultados em Runtime a partir de 50 objetos já demonstraram uma queda brusca na performance. Com 100 objetos ou mais não foi possível realizar as medições, pois o programa não respondeu mais ao iniciar a execução.

\subsection{\emph{Polygon Collider - Pre-Runtime}}

Os resultados com um e cem objetos, demonstram boa estabilidade  de consumo de recursos, mantendo o tempo de consumo total da CPU entre 0.1 ms e 1 ms, como mostra a Figura \ref{teste_polygon_0010_static}. O consumo total de memória RAM variou entre 270 MB e 180 MB.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/0010_Static.png}
	\caption[Resultado 0010 Objetos Polygon Static]{Resultado de performance de dez objetos com \emph{polygon collider} em \emph{Pre-Runtime}.}
	\label{teste_polygon_0010_static}
\end{figure}

A partir de 50 objetos, houve um consumo maior de CPU, fazendo o tempo total de uso da mesma ser entre 5 ms a 16 ms. No entanto, apesar do consumo total de memória RAM se manteve estável como mostra a Figura \ref{teste_polygon_0050_static}, a performance começa a cair gradativamente.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/0050_Static.png}
	\caption[Resultado 0050 Objetos Polygon Static]{Resultado de performance de cinquenta objetos com \emph{polygon collider} em \emph{Pre-Runtime}.}
	\label{teste_polygon_0050_static}
\end{figure}

Com cem objetos a performance diminui pouco, relativamente ao resultado anterior. O consumo total de memória RAM se mantém, e o tempo de consumo da CPU teve um pico de 66 ms, porém, em sua maioria, manteve estável entre 33 ms e 16 ms como mostra a Figura .

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/0100_Static.png}
	\caption[Resultado 0100 Objetos Polygon Static]{Resultado de performance de cem objetos com \emph{polygon collider} em \emph{Pre-Runtime}.}
	\label{teste_polygon_0100_static}
\end{figure}

Os resultados com quinhentos e mil objetos demonstraram uma queda drástica na performance, além de uso elevado dos recursos, com consumo total de memória RAM sendo de 0.99 GB e 1.88 GB respectivamente, e em ambos o tempo de consumo de CPU passou de 66 ms, como mostra a Figura \ref{teste_polygon_0500_static}. Com mil objetos, a taxa de quadros por segundo se manteve em 0.6 (1638 ms), como mostra a Figura .

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/0500_Static.png}
	\caption[Resultado 0500 Objetos Polygon Static]{Resultado de performance de quinhentos objetos com \emph{polygon collider} em \emph{Pre-Runtime}.}
	\label{teste_polygon_0500_static}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/1000_Static_FPS.png}
	\caption[FPS 1000 Objetos Polygon Static]{Captura de quadros por segundo média aproximada com \emph{polygon collider} em \emph{Pre-Runtime} e mil objetos.}
	\label{teste_polygon_1000_static_fps}
\end{figure}

\subsection{\emph{Polygon Collider - Runtime}}

O resultado com um objeto por segundo foi relativamente estável, apresentando tempo de consumo de CPU com média de 1 ms e consumo total de memória RAM com 230 MB, como mostra a Figura \ref{teste_polygon_0001_dynamic}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/0001_Dynamic.png}
	\caption[Resultado 0001 Objetos Polygon Dynamic]{Resultado de performance de um objeto com \emph{polygon collider} em \emph{Runtime}.}
	\label{teste_polygon_0001_dynamic}
\end{figure}

A partir de 10 objetos por segundo a performance começa a cair conforme o tempo de execução passa e os objetos são inseridos. Inicialmente o tempo de consumo de CPU era de cerca de 16 ms, porém rapidamente passou de 66 ms como mostra a Figura \ref{teste_polygon_0010_dynamic}. O consumo de memória RAM total foi de cerca de 500 MB.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/0010_Dynamic.png}
	\caption[Resultado 0010 Objetos Polygon Dynamic]{Resultado de performance de dez objetos com \emph{polygon collider} em \emph{Runtime}.}
	\label{teste_polygon_0010_dynamic}
\end{figure}

Com 50 Objetos, a performance é comprometida desde o início da execução, fazendo com que o programa travasse com frequência. O tempo de consumo de CPU que foi possível medir passou de 66 ms e consumo total de memória RAM de 335 MB como mostra a Figura \ref{teste_polygon_0050_dynamic} até ser encerrada a execução pelo programa por travar frequentemente. O programa indicou 0.8 quadros por segundo (1209 ms) como mostra a Figura  e se manteve assim durante o resto da execução

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/0050_Dynamic_Stats.png}
	\caption[Resultado 0050 Objetos Polygon Dynamic]{Resultado de performance de cinquenta objetos com \emph{polygon collider} em \emph{Runtime}.}
	\label{teste_polygon_0050_dynamic}
\end{figure}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figuras/Testes/Polygon/new/0050_Dynamic_FPS.png}
	\caption[FPS 0050 Objetos Polygon Dynamic]{Captura de quadros por segundo média aproximada com \emph{polygon collider} em \emph{Runtime} e cinquenta objetos.}
	\label{teste_polygon_0050_dynamic_fps}
\end{figure}

Com cem objetos por segundo, o programa inicia, porém não prossegue com a execução. Por manter-se parado dessa forma por um longo período de tempo, essa comparação foi cancelada e não foi possível obter resultados.

As comparações com quinhentos e mil objetos por segundo apresentaram o mesmo efeito e também foram cancelados.